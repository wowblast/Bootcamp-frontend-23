"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setLogger = exports.getLogger = exports.newHttpClient = exports.InstalledFilter = exports.FilterCollection = exports.Response = exports.Request = void 0;
var filterChainImpl_1 = require("./filterChainImpl");
// Main class to make calls to the API
// method call will call method doFilter and it will call method execute
var HttpClientImpl = /** @class */ (function () {
    function HttpClientImpl() {
        this._filters = [];
    }
    // Takes parameters and creates an InstalledFilter with them
    // Add the InstalledFilter to the filter array
    // The InstalledFilter is made of two parts: The Filter and the FilterConfig
    HttpClientImpl.prototype.addFilter = function (filter, name, config) {
        var installedFilter = new InstalledFilter(filter, name, config);
        var filters = this._filters;
        // Returns an object with a method to remove the added filter
        filters.push(installedFilter);
        return {
            remove: function () {
                remove(installedFilter, filters);
            }
        };
    };
    // Takes a Request and returns the body of the promise returned by the method callForResponse
    HttpClientImpl.prototype.execute = function (call) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.callForResponse(call)];
                    case 1: return [2 /*return*/, (_a.sent()).body
                        // body can be null but in such cases, an error will be thrown
                    ];
                }
            });
        });
    };
    // Takes a Request, creates the main chain of filters with the current filters of httpclient
    // and then calls the method doFilter with the received Request
    HttpClientImpl.prototype.executeForResponse = function (call) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new filterChainImpl_1.default(this._filters).doFilter(call)];
            });
        });
    };
    // Same as execute
    HttpClientImpl.prototype.call = function (call) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.execute(call)];
            });
        });
    };
    // Same as executeForResponse
    HttpClientImpl.prototype.callForResponse = function (call) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.executeForResponse(call)];
            });
        });
    };
    return HttpClientImpl;
}());
// Contains every parameter needed for a request as properties
var Request = /** @class */ (function () {
    // constructor that can take a lot of parameters but only the URL is mandatory
    function Request(url, _a) {
        var _b = _a === void 0 ? {} : _a, contentType = _b.contentType, method = _b.method, responseType = _b.responseType, withCredentials = _b.withCredentials, body = _b.body, headers = _b.headers, timeout = _b.timeout;
        this.aborted = false;
        this.contentType = 'application/json; charset=UTF-8';
        // A way to declare an enumeration (can be anything because of the string but the IDE will suggest the 4 first verbs)
        this.method = 'GET';
        this.responseType = 'json';
        this.withCredentials = false;
        this.headers = {};
        this.timeout = 30000;
        this.readyState = 0;
        this.properties = {};
        this.url = url;
        if (contentType) {
            this.contentType = contentType;
        }
        if (method) {
            this.method = method;
        }
        if (responseType) {
            this.responseType = responseType;
        }
        if (withCredentials) {
            this.withCredentials = withCredentials;
        }
        if (body) {
            this.body = body;
        }
        if (headers) {
            this.headers = headers;
        }
        if (timeout) {
            this.timeout = timeout;
        }
        this.upload = {
            onprogress: function () { return void 0; },
            onloadstart: function () { return void 0; }
        };
    }
    Object.defineProperty(Request.prototype, "xhr", {
        get: function () {
            return this._xhr;
        },
        set: function (xhr) {
            if (this.aborted) {
                throw Error('request aborted');
            }
            this._xhr = xhr;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Request.prototype, "isAborted", {
        get: function () {
            return this.aborted;
        },
        enumerable: false,
        configurable: true
    });
    Request.prototype.abort = function () {
        if (this.xhr) {
            this.xhr.abort();
        }
        this.aborted = true;
    };
    // sets the properties (like a constructor for changes)
    Request.prototype.set = function (_a) {
        var contentType = _a.contentType, method = _a.method, responseType = _a.responseType, withCredentials = _a.withCredentials, body = _a.body, headers = _a.headers, timeout = _a.timeout;
        if (contentType) {
            this.contentType = contentType;
        }
        if (method) {
            this.method = method;
        }
        if (responseType) {
            this.responseType = responseType;
        }
        if (withCredentials) {
            this.withCredentials = withCredentials;
        }
        if (body) {
            this.body = body;
        }
        if (headers) {
            this.headers = headers;
        }
        if (timeout) {
            this.timeout = timeout;
        }
        return this;
    };
    Request.prototype.setContentType = function (contentType) {
        this.contentType = contentType;
        return this;
    };
    Request.prototype.setMethod = function (method) {
        if (method === void 0) { method = 'GET'; }
        this.method = method;
        return this;
    };
    Request.prototype.setResponseType = function (responseType) {
        this.responseType = responseType;
        return this;
    };
    Request.prototype.setWithCredentials = function (withCredentials) {
        this.withCredentials = withCredentials;
        return this;
    };
    Request.prototype.setBody = function (body) {
        this.body = body;
        return this;
    };
    Request.prototype.setHeaders = function (headers) {
        this.headers = headers;
        return this;
    };
    Request.prototype.addHeader = function (headerName, value) {
        this.headers[headerName] = value;
    };
    Request.prototype.setTimeout = function (timeout) {
        this.timeout = timeout;
        return this;
    };
    Request.prototype.setProperty = function (key, value) {
        this.properties[key] = value;
        return this;
    };
    Request.prototype.getProperty = function (key) {
        return this.properties[key];
    };
    return Request;
}());
exports.Request = Request;
// The class that our calls return
var Response = /** @class */ (function () {
    function Response(request, status, statusText, headers, body) {
        this.request = request;
        this.status = status;
        this.statusText = statusText;
        this.headers = headers;
        this.body = body;
        this.properties = {};
    }
    Response.prototype.setProperty = function (key, value) {
        this.properties[key] = value;
        return this;
    };
    Response.prototype.getProperty = function (key) {
        return this.properties[key];
    };
    return Response;
}());
exports.Response = Response;
// Third parameter is a function that will call the execute method with a given request
// Only the first parameter of the constructor is obligatory
// Has all the filters that could be applied to a request
// Goes throught them and applies them to the request if the config is matching
var FilterCollection = /** @class */ (function () {
    function FilterCollection(filters) {
        this.filters = filters;
    }
    /**
     * @param call Is the request we want to modify
     * @param filterChain is an Interface that is a Filter, but its goal is to simulate
     * nested filters. So it contains an array of filter and its doFilter loops through all its filters
     * before continuing with the main chain of filters
     */
    FilterCollection.prototype.doFilter = function (call, filterChain) {
        return new filterChainImpl_1.default(this.filters, 0, function (request) { return filterChain.doFilter(request); }).doFilter(call);
    };
    return FilterCollection;
}());
exports.FilterCollection = FilterCollection;
/**
 * Is composed of a FilterConfig that checks the request to know if the Filter should be applied
 * and of a Filter that does something to the request/response
 */
var InstalledFilter = /** @class */ (function () {
    function InstalledFilter(filter, name, config) {
        this.filter = filter;
        this.name = name;
        this.config = config;
    }
    return InstalledFilter;
}());
exports.InstalledFilter = InstalledFilter;
/*
    Factory method
*/
function newHttpClient() {
    return new HttpClientImpl();
}
exports.newHttpClient = newHttpClient;
var log;
function getLogger() {
    return log;
}
exports.getLogger = getLogger;
function setLogger(logger) {
    log = logger;
}
exports.setLogger = setLogger;
// Utility methods
function remove(item, array) {
    var index = array.indexOf(item, 0);
    if (index > -1) {
        array.splice(index, 1);
    }
}
//# sourceMappingURL=index.js.map