"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var generic_logger_typings_1 = require("generic-logger-typings");
var index_1 = require("./index");
// Global function that takes a request (after being filtered), send it to the API and gives us its response
function execute(request) {
    var log = (0, index_1.getLogger)();
    // Returns a new Promise
    return new Promise(function (resolve, reject) {
        var traceMessage = '';
        if (log === null || log === void 0 ? void 0 : log.isLevelEnabled(generic_logger_typings_1.LogLevel.TRACE)) {
            // Takes care of the logs
            traceMessage = request.method + " " + request.url;
            if (request.body) {
                if (typeof request.body === 'string') {
                    traceMessage += " --> " + request.body;
                }
                else if (!(request.body instanceof Blob ||
                    request.body instanceof ArrayBuffer
                    || request.body instanceof ReadableStream
                    || request.body instanceof Document)) {
                    traceMessage += " --> " + JSON.stringify(request.body);
                }
            }
        }
        // Creating a new XMLHttpRequest and giving it two properties from the request this method received
        // This will be the request we will send to the server
        if (request.isAborted) {
            request.readyState = 4;
            reject(new index_1.Response(request, 0, 'OK', {}, null));
        }
        else {
            var xhr_1 = new XMLHttpRequest();
            request.xhr = xhr_1;
            xhr_1.withCredentials = request.withCredentials;
            xhr_1.timeout = request.timeout;
            try {
                xhr_1.upload.onloadstart = request.upload.onloadstart;
                xhr_1.upload.onprogress = request.upload.onprogress;
            }
            catch (e) { /* ignore error NodeJs only */ }
            // This internal method takes the xml request and retrieves headers from it
            var parseResponseHeaders_1 = function (request) {
                // Creates a map of header names to values
                var headerMap = {};
                // Gets the raw header string
                var headers = request.getAllResponseHeaders();
                if (headers) {
                    // Converts the header string into an array
                    // of individual headers
                    var arr = headers.trim().split(/[\r\n]+/);
                    // Splits every header in multiple key-value pairs
                    arr.forEach(function (line) {
                        line = line.trim();
                        if (line.length > 0) {
                            var parts = line.split(': ');
                            if (parts.length >= 2) {
                                var header = parts.shift();
                                headerMap[header] = parts.join(': ');
                            }
                        }
                    });
                }
                return headerMap;
            };
            // This internal method takes an XMLHttpRequest and will return a Response
            // The request of the returned Response will stay as it was, only its readystate will be updated
            // The rest of the returned Repsponse will be update accordingly to the XMLHttpRequest this method receives
            var buildResponseAndUpdateRequest_1 = function (req) {
                // Puting the newly received ready state in the request the global method received
                // because we will return it contained in the Response
                request.readyState = req.readyState;
                // Getting the response of the XMLHttpRequest we receive
                var responseBody = req.response;
                // Some implementations of XMLHttpRequest ignore the "json" responseType
                // Checking if the form of the request the parent method received is correct
                if (request.responseType === 'json'
                    && typeof responseBody === 'string'
                    && (req.responseType === '' || req.responseType === 'text')
                    && responseBody.length === req.responseText.length
                    && req.responseText.length > 0) {
                    // TODO: if error here around, it isn't bubble up ! Please AB fix it
                    log === null || log === void 0 ? void 0 : log.trace("Parsing JSON");
                    try {
                        responseBody = JSON.parse(responseBody);
                    }
                    catch (e) {
                        responseBody = undefined;
                    }
                }
                // We return a response with the request of the parent method (only the readystate has changed)
                // We add to it a couple of properties from the request this method received
                // And wrap it up into our Response class
                return new index_1.Response(request, req.status, req.statusText, parseResponseHeaders_1(req), responseBody);
            };
            // When the promise is returned, we call the buildResponseAndUpdateRequestMethod
            // And this is what will give us our final Response
            var rejectRequest_1 = function (req) {
                reject(buildResponseAndUpdateRequest_1(req));
            };
            var resolveRequest_1 = function (req) {
                resolve(buildResponseAndUpdateRequest_1(req));
            };
            // Defining the main xmlHttpRequest properties (methods)
            xhr_1.onerror = function () {
                if (log === null || log === void 0 ? void 0 : log.isLevelEnabled(generic_logger_typings_1.LogLevel.TRACE)) {
                    log.trace(xhr_1.status + " " + traceMessage);
                }
                rejectRequest_1(xhr_1);
            };
            xhr_1.onabort = xhr_1.onerror;
            xhr_1.ontimeout = xhr_1.onerror;
            xhr_1.onload = function () {
                if (log === null || log === void 0 ? void 0 : log.isLevelEnabled(generic_logger_typings_1.LogLevel.TRACE)) {
                    log.trace(xhr_1.status + " " + traceMessage);
                }
                if (xhr_1.status >= 200 && xhr_1.status < 400) {
                    // Success!
                    resolveRequest_1(xhr_1);
                }
                else {
                    rejectRequest_1(xhr_1);
                }
            };
            // Initializes the request
            xhr_1.open(request.method, request.url);
            // Copying the response type from the Request we received
            xhr_1.responseType = request.responseType;
            // Adapting the main XMLHttpRequest according to the passed Request
            if (request.responseType === 'json') {
                xhr_1.setRequestHeader('Accept', 'application/json');
            }
            for (var headerName in request.headers) {
                xhr_1.setRequestHeader(headerName, request.headers[headerName]);
            }
            xhr_1.setRequestHeader('Content-Type', request.contentType);
            var body = request.body;
            // Auto-stringify json objects
            if (typeof body === 'object' && request.contentType.toLowerCase().includes('application/json')) {
                body = JSON.stringify(body);
            }
            // Sending request to the server
            xhr_1.send(body);
        }
    });
}
exports.default = execute;
//# sourceMappingURL=execute.js.map