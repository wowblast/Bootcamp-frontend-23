import type { Logger } from 'generic-logger-typings';
/**
 * In order to be an HttpClient, the class should:
 * Make a call to the server and returning a response
 * Make a simpler call to the server that only returns a part of the response
 * Add a filter to its filter list
 */
export interface HttpClient {
    executeForResponse<T>(request: Request): Promise<Response<T>>;
    callForResponse<T>(request: Request): Promise<Response<T>>;
    execute<T>(request: Request): Promise<T>;
    call<T>(request: Request): Promise<T>;
    addFilter(filter: Filter<unknown, unknown>, name: string, config?: FilterConfig): FilterRegistration;
}
export interface Headers {
    [name: string]: string;
}
export declare class Request {
    private _xhr;
    private aborted;
    set xhr(xhr: XMLHttpRequest | undefined);
    get xhr(): XMLHttpRequest | undefined;
    get isAborted(): boolean;
    abort(): void;
    upload: {
        onprogress: {
            (event: Event): void;
        };
        onloadstart: {
            (event: Event): void;
        };
    };
    url: string;
    contentType: string;
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | string;
    responseType: XMLHttpRequestResponseType;
    withCredentials: boolean;
    body?: object | Document | BodyInit | null;
    headers: Headers;
    timeout: number;
    readyState: number;
    properties: {
        [key: string]: unknown;
    };
    constructor(url: string, { contentType, method, responseType, withCredentials, body, headers, timeout }?: {
        contentType?: string;
        method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | string;
        responseType?: XMLHttpRequestResponseType;
        withCredentials?: boolean;
        body?: object | Document | BodyInit | null;
        headers?: Headers;
        timeout?: number;
    });
    set({ contentType, method, responseType, withCredentials, body, headers, timeout }: {
        contentType?: string;
        method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | string;
        responseType?: XMLHttpRequestResponseType;
        withCredentials?: boolean;
        body?: object | Document | BodyInit | null;
        headers?: Headers;
        timeout?: number;
    }): Request;
    setContentType(contentType: string): Request;
    setMethod(method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | string): Request;
    setResponseType(responseType: XMLHttpRequestResponseType): this;
    setWithCredentials(withCredentials: boolean): this;
    setBody(body?: object | Document | BodyInit | null): this;
    setHeaders(headers: Headers): this;
    addHeader(headerName: string, value: string): void;
    setTimeout(timeout: number): this;
    setProperty(key: string, value: unknown): this;
    getProperty(key: string): unknown;
}
export declare class Response<T> {
    readonly request: Request;
    readonly status: number;
    readonly statusText: string;
    readonly headers: Headers;
    readonly body: T | null;
    readonly properties: {
        [key: string]: unknown;
    };
    constructor(request: Request, status: number, statusText: string, headers: Headers, body: T | null);
    setProperty(key: string, value: unknown): this;
    getProperty(key: string): unknown;
}
/**
 * Interface useful to remove a Filter after it has been added to the httpClient array
 */
export interface FilterRegistration {
    remove(): void;
}
/**
 * A FilterChain should have a method to apply all its filters
 * on a Request and send it to the server
 */
export interface FilterChain<T> {
    doFilter(call: Request): Promise<Response<T>>;
}
export declare class FilterCollection implements Filter<unknown, unknown> {
    readonly filters: InstalledFilter[];
    constructor(filters: InstalledFilter[]);
    /**
     * @param call Is the request we want to modify
     * @param filterChain is an Interface that is a Filter, but its goal is to simulate
     * nested filters. So it contains an array of filter and its doFilter loops through all its filters
     * before continuing with the main chain of filters
     */
    doFilter(call: Request, filterChain: FilterChain<unknown>): Promise<Response<unknown>>;
}
/**
 * Is composed of a FilterConfig that checks the request to know if the Filter should be applied
 * and of a Filter that does something to the request/response
 */
export declare class InstalledFilter {
    readonly filter: Filter<unknown, unknown>;
    readonly name: string;
    readonly config?: FilterConfig | undefined;
    constructor(filter: Filter<unknown, unknown>, name: string, config?: FilterConfig | undefined);
}
export interface FilterConfig {
    enabled(call: Request): boolean;
}
export interface Filter<T, U> {
    doFilter(call: Request, filterChain: FilterChain<T>): Promise<Response<U>>;
}
export declare function newHttpClient(): HttpClient;
export declare function getLogger(): Logger | undefined;
export declare function setLogger(logger: Logger): void;
